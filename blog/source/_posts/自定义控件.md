---
title: 自定义控件
date: 2017-03-20 14:58:21
tags:
- 笔记
- view
categories:
- 笔记
- 自定义view
---
# 自定义控件学习笔记

## measure

### ViewGroup 中measureChildWithMargins 调用 View的measure()
```java
protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
               //获取child的LayoutParams
        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed,
                lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed,
                lp.height);
                //调用child的measure方法
        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
```
<!-- more -->
其中getChildMeasureSpeac(int spec, int padding, int childDimension)
```java
public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
       //获取ViewGroup的参数
       int specMode = MeasureSpec.getMode(spec);
       int specSize = MeasureSpec.getSize(spec);
       //获取可以使用的最大的size
       int size = Math.max(0, specSize - padding);

       int resultSize = 0;
       int resultMode = 0;

       //根据父控件的specMode分配子空间的大小 和 方式
       switch (specMode) {
       case MeasureSpec.EXACTLY:
       //childDimension是child的具体设置高度 如果<0则是match 或者 wrap
           if (childDimension >= 0) {
               resultSize = childDimension;
               resultMode = MeasureSpec.EXACTLY;
           } else if (childDimension == LayoutParams.MATCH_PARENT) {
               resultSize = size;
               resultMode = MeasureSpec.EXACTLY;
           } else if (childDimension == LayoutParams.WRAP_CONTENT) {
               resultSize = size;
               resultMode = MeasureSpec.AT_MOST;
           }
           break;

       case MeasureSpec.AT_MOST:
           if (childDimension >= 0) {
               resultSize = childDimension;
               resultMode = MeasureSpec.EXACTLY;
           } else if (childDimension == LayoutParams.MATCH_PARENT) {
               resultSize = size;
               resultMode = MeasureSpec.AT_MOST;
           } else if (childDimension == LayoutParams.WRAP_CONTENT) {
               resultSize = size;
               resultMode = MeasureSpec.AT_MOST;
           }
           break;

       // 一般不会使用 这个代表不会管理子View的大小 例如ScrollView
       case MeasureSpec.UNSPECIFIED:
           if (childDimension >= 0) {
               resultSize = childDimension;
               resultMode = MeasureSpec.EXACTLY;
           } else if (childDimension == LayoutParams.MATCH_PARENT) {
               //View.sUseZeroUnspecifiedMeasureSpec=true 5.0以下
               //5.0 以上 就是 false
               resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
               resultMode = MeasureSpec.UNSPECIFIED;
           } else if (childDimension == LayoutParams.WRAP_CONTENT) {
               resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
               resultMode = MeasureSpec.UNSPECIFIED;
           }
           break;
       }
       return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
   }
```
總的來説就是這樣的 MeasureSpec.UNSPECIFIED 5.0 以上以下有区别 一般不会用到

 |  Child \ Parent        | MeasureSpec.EXACTLY    |  MeasureSpec.AT_MOST   | MeasureSpec.UNSPECIFIED|
 | :-------:              | :-----:                | :----:                 | :----:                 |
 | 具體尺寸   |  size=具體 MeasureSpec.EXACTLY  | size=具體 MeasureSpec.EXACTLY | size = 具體   MeasureSpec.EXACTLY |
 | WRAP_CONTENT |size=size MeasureSpec.AT_MOST| size=size MeasureSpec.AT_MOST |size=size MeasureSpec.UNSPECIFIED|
 | MATCH_PARENT| size=size MeasureSpec.EXACTLY | size=size MeasureSpec.AT_MOST | size=size MeasureSpec.UNSPECIFIED|

 ### view的measure(childWidthMeasureSpec, childHeightMeasureSpec)方法
 measure()---这个方法用于设定这个子View到底有多大，并且调用onMeasure()方法
 ```java
 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
       setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
               getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
   }
 ```
getSuggestedMinimumHeight() 与 getSuggestedMinimumWidth() 方法雷同 用于计算 最小的值 背景与view自身设置的值
```java
protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }
```
getDefaultSize() 最终根据自身的MeasureSpec.Mode 来决定自身到底有多大
```java
public static int getDefaultSize(int size, int measureSpec) {
       int result = size;
       int specMode = MeasureSpec.getMode(measureSpec);
       int specSize = MeasureSpec.getSize(measureSpec);

       switch (specMode) {
       case MeasureSpec.UNSPECIFIED:  
           result = size; //这个size是getSuggestedMinimumWidth中获得的最小度  一般=不会用到 但是在lsitView中高度设定不相符时使用min来设定可以确定高度
           break;
       case MeasureSpec.AT_MOST:
       case MeasureSpec.EXACTLY:
           result = specSize;
           break;
       }
       return result;
   }
```
### 重点强调的是 自定义控件的onmeasure方法重写 必须设定WRAP_CONTENT时的状态
因为在WRAP_CONTENT情况下 measure的模式为MeasureSpec,AT_MOST 并且大小也与父控件大小相同 这样的话 WRAP_CONTENT就与MATCH_PARENT的效果相同 必须要重写设置大小
```java
@Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

       int widthMode = MeasureSpec.getMode(widthMeasureSpec);
       int heightMode = MeasureSpec.getMode(heightMeasureSpec);

       int width = 100; //这个高度宽度需要计算 计算出自己到底需要多少
       int height = 100;

       if (widthMode == MeasureSpec.AT_MOST && heightMode == MeasureSpec.AT_MOST) { // 添加判断才可以确定具体尺寸来设置WRAP_CONTENT
           setMeasuredDimension(width, height);
       } else if (widthMode == MeasureSpec.AT_MOST) {
           setMeasuredDimension(width, getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
       } else if (height == MeasureSpec.AT_MOST) {
           setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), height);
       } else {
           super.onMeasure(widthMeasureSpec, heightMeasureSpec);
       }

   }
```
